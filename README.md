# Warp-Scheduler
A Verilog-based RTL implementation of a Round-Robin Warp Scheduler, simulating how modern GPUs select warps for execution. The design models 32 warp lanes using bitmasks and supports ready/stall status for realistic thread handling. Includes testbenches, waveform output, and Yosys synthesis support.

--- 

## 🚀 Overview

GPUs execute many threads in parallel using the concept of "warps" (a group of 32 threads). A warp scheduler decides which warp to issue next for execution based on readiness and stalls. This design simulates this using:
- 32-bit ready and stalled vectors.
- Round-robin traversal using a rotating pointer.
- Eligibility mask calculation.
- Verilog-based RTL implementation.

--- 

## 📁 Files

| File                  | Description |
|-----------------------|-------------|
| `warp_scheduler.v`    | RTL module implementing the warp scheduler logic. |
| `tb_warp_scheduler.v` | Testbench to verify functionality via simulation. |
| `waves.vcd`           | VCD output file for waveform visualization. |
| `Output.png`          | Waveform Visualization Image.               |
| `synth.ys`            | Yosys script for synthesis and optimization of the RTL.|
| `warp_scheduler.blif` | Gate-level netlist in BLIF format generated by Yosys.|
| `warp_scheduler_optimized.v` | Synthesized and optimized Verilog after Yosys processing. |
| `schematic.png`       | Graphviz-rendered RTL structure from Yosys. |

---

## How It Works

The **Round-Robin Warp Scheduler** mimics a key scheduling mechanism used in modern GPUs for managing multiple threads or "warps". In this project, the system considers 32 warps, each represented by a bit in a 32-bit vector. Two input signals, `warp_ready` and `warp_stalled`, indicate which warps are eligible for execution and which ones are currently stalled.

The core of the design lies in the use of bitmasking — combining `warp_ready` with the inverse of `warp_stalled` to calculate `warp_eligible`. The scheduler then uses a round-robin approach to pick the next warp: starting from the current pointer (`current_ptr`), it first checks whether that warp is eligible, and if not, searches circularly through the 32 warps for the next eligible one. Once a warp is selected, the `next_warp` output is updated, and a valid signal (`warp_valid`) is asserted. The `current_ptr` then moves forward, ensuring that no single warp dominates execution.

This project simulates a fundamental concept used in real-world GPU architectures to manage thousands of concurrent threads efficiently. By implementing this in Verilog, we get a cycle-accurate RTL model that can be tested, visualized through waveforms, and synthesized using tools like Yosys. The testbench demonstrates how different `warp_ready` combinations influence the scheduler’s decisions.

---

## 🔧 Installation

To run and simulate this RTL design on your local system:

- Install Icarus Verilog
  ```
  sudo apt update
  sudo apt install iverilog gtkwave
  ```
- Clone the Repository
  ```
   git clone https://github.com/riaagarwal21/Warp-Scheduler
  ```
- Run the Simulation
  
  Open your project root and use the following commands to run the simulation:
  
  ```
  iverilog -o sim warp_scheduler.v tb_waarp_scheduler.v
  vvp sim
  ```
- View Waveform
  ```
  gtkwave waves.vcd
  ```

### Yosys Synthesis SetUp (Optional)
- Install Yosys
  ```
  sudo apt install yosys
  ```
- Run Synthesis
  ```
  yosys synth.ys
  ```
- Generate Schematic
  ```
  dot -Tpng warp_sched.dot -o schematic.png
  ```
---

> 📌 Created with ❤️ by Ria Agarwal
